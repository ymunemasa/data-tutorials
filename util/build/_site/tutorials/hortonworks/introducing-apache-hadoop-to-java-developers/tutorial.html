

<div class="tutorial-content">
  <h2 id="introduction">Introduction</h2>

<p>In this tutorial for Hadoop Developers, we will explore the core concepts of Apache Hadoop and examine the process of writing a MapReduce Program.</p>

<h2 id="pre-requisite">Pre-Requisite</h2>
<ul>
  <li>Downloaded and Installed latest <a href="http://hortonworks.com/products/hortonworks-sandbox/#install">Hortonworks Sandbox</a></li>
  <li><a href="http://hortonworks.com/hadoop-tutorial/learning-the-ropes-of-the-hortonworks-sandbox/">Learning the Ropes of the Hortonworks Sandbox</a></li>
  <li>Allow yourself around 1 to 2 hours to complete this tutorial</li>
</ul>

<h2 id="outline">Outline</h2>

<ul>
  <li><a href="#hadoop-concept">Hadoop</a></li>
  <li><a href="#core-apache-hadoop">Step 1: Explore the Core Concepts of Apache Hadoop</a>
    <ul>
      <li><a href="#what-is-mapreduce">1.1 What is MapReduce?</a></li>
      <li><a href="#mapreduce-concepts-terminology">1.2 The MapReduce Concepts and Terminology</a></li>
      <li><a href="#mapreduce-the-mapper">1.3 MapReduce: The Mapper</a></li>
      <li><a href="#mapreduce-the-reducer">1.4 MapReduce: The Reducer</a></li>
    </ul>
  </li>
  <li><a href="#write-a-mapreduce-program">Step 2: Write a MapReduce program</a>
    <ul>
      <li><a href="#examine-the-mapreduce-example">2.1 Examine The MapReduce Example</a></li>
      <li><a href="#mapper-reading-data-hdfs">2.2 Mapper reading data from HDFS</a></li>
      <li><a href="#streaming-api">2.3 Streaming API</a></li>
      <li><a href="#repositories-hortonworks">2.4 Repositories</a></li>
      <li><a href="#source-javadoc">2.5 Source &amp; Javadoc</a></li>
      <li><a href="#sbt-setup">2.6 SBT Setup</a></li>
      <li><a href="#gradle-setup">2.7 Gradle Setup</a></li>
    </ul>
  </li>
  <li><a href="#hive-and-pig-motivation">Step 3: Hive and Pig: Motivation</a></li>
  <li><a href="#further-reading-java-dev">Further Reading</a></li>
</ul>

<h2 id="hadoop-a-idhadoop-concepta">Hadoop <a id="hadoop-concept"></a></h2>

<p>Apache Hadoop is a community driven open-source project goverened by the <a href="http://apache.org">Apache Software Foundation</a>.</p>

<p>It was originally implemented at Yahoo based on papers published by Google in 2003 and 2004. Hadoop committers today work at several different organizations like Hortonworks, Microsoft, Facebook, Cloudera and many others around the world.</p>

<p>Since then Apache Hadoop has matured and developed to become a data platform for not just processing humongous amount of data in batch but with the advent of <a href="http://hortonworks.com/hadoop/yarn/">YARN</a> it now supports many diverse workloads such as Interactive queries over large data with <a href="http://hortonworks.com/labs/stinger/">Hive on Tez</a>, Realtime data processing with <a href="http://hortonworks.com/labs/storm/">Apache Storm</a>, super scalable NoSQL datastore like <a href="http://hortonworks.com/hadoop/hbase/">HBase</a>, in-memory datastore like <a href="http://hortonworks.com/hadoop/spark/">Spark</a> and the list goes on.</p>

<p><img src="https://raw.githubusercontent.com/hortonworks/tutorials/hdp/assets/introducing-hadoop-to-java-developers/5-boxes.png" alt="" /></p>

<blockquote>
  <p>Hortonworks Data Platform</p>
</blockquote>

<h3 id="step-1-explore-the-core-concepts-of-apache-hadoop-a-idcore-apache-hadoopa">Step 1: Explore the Core Concepts of Apache Hadoop <a id="core-apache-hadoop"></a></h3>

<ul>
  <li>The Hadoop Distributed File System (HDFS)</li>
  <li>MapReduce</li>
</ul>

<p>A Hadoop Cluster is a set of machines that run HDFS and MapReduce. Nodes are individual machines. A cluster can have as few as one node to several thousands of nodes. For most application scenarios, Hadoop is linearly scalable, which means you can expect better performance by simply adding more nodes.</p>

<h4 id="what-is-mapreduce-a-idwhat-is-mapreducea">1.1 What is MapReduce? <a id="what-is-mapreduce"></a></h4>

<p>MapReduce is a method for distributing a task across multiple nodes. Each node processes data stored on that node to the extent possible.</p>

<p>A running Map Reduce job consists of various phases such as <code class="highlighter-rouge">Map  -&gt;  Sort  -&gt;  Shuffle  -&gt;  Reduce</code></p>

<p>The primary advantages of abstracting your jobs as MapReduce, which run over a distributed infrastructure like CPU and Storage are:</p>

<ul>
  <li>Automatic parallelization and distribution of data in blocks across a distributed, scale-out infrastructure.</li>
  <li>Fault-tolerance against failure of storage, compute and network infrastructure</li>
  <li>Deployment, monitoring and security capability</li>
  <li>A clean abstraction for programmers</li>
</ul>

<p>Most MapReduce programs are written in Java. It can also be written in any scripting language using the Streaming API of Hadoop. MapReduce abstracts all the low level plumbing away from the developer such that developers can concentrate on writing the Map and Reduce functions.</p>

<h4 id="the-mapreduce-concepts-and-terminology-a-idmapreduce-concepts-terminologya">1.2 The MapReduce Concepts and Terminology <a id="mapreduce-concepts-terminology"></a></h4>

<p>MapReduce jobs are controlled by a software daemon known as the <code class="highlighter-rouge">JobTracker</code>. The JobTracker resides on a 'master node'. Clients submit MapReduce jobs to the JobTracker. The JobTracker assigns Map and Reduce tasks to other nodes on the cluster.</p>

<p>These nodes each run a software daemon known as the <code class="highlighter-rouge">TaskTracker</code>. The TaskTracker is responsible for actually instantiating the Map or Reduce task, and reporting progress back to the JobTracker</p>

<p>A <code class="highlighter-rouge">job</code> is a program with the ability to execute Mappers and Reducers over a dataset. A <code class="highlighter-rouge">task</code> is the execution of a single Mapper or Reducer over a slice of data.</p>

<p>There will be at least as many task attempts as there are tasks. If a task attempt fails, another will be started by the JobTracker. Speculative execution can also result in more task attempts than completed tasks.</p>

<h4 id="mapreduce-the-mapper-a-idmapreduce-the-mappera">1.3 MapReduce: The Mapper <a id="mapreduce-the-mapper"></a></h4>

<p>Hadoop attempts to ensure that Mappers run on nodes, which hold their portion of the data locally, to minimize network traffic. Multiple Mappers run in parallel, each processing a portion of the input data.</p>

<p>The Mapper reads data in the form of key/value pairs. It outputs zero or more key/value pairs</p>

<div class="highlighter-rouge"><pre class="highlight"><code>map(in_key, in_value) -&gt; (inter_key, inter_value) list
</code></pre>
</div>

<p>The Mapper may use or completely ignore the input key. For example, a standard pattern is to read a file one line at a time. The key is the byte offset into the file at which the line starts. The value is the contents of the line itself. Typically the key is considered irrelevant. If the Mapper writes anything out, the output must be in the form of key/value pairs.</p>

<h4 id="mapreduce-the-reducer-a-idmapreduce-the-reducera">1.4 MapReduce: The Reducer <a id="mapreduce-the-reducer"></a></h4>

<p>After the Map phase is over, all the intermediate values for a given intermediate key are combined together into a list. This list is given to a Reducer. There may be a single Reducer, or multiple Reducers, this is specified as part of the job configuration. All values associated with a particular intermediate key are guaranteed to go to the same Reducer.</p>

<p>The intermediate keys and their value lists are passed to the Reducer in sorted key order. This step is known as the <strong><em>shuffle and sort</em></strong>. The Reducer outputs zero or more final key/value pairs. These are written to HDFS. In practice, the Reducer usually emits a single key/value pair for each input key.</p>

<p>It is possible for some Map tasks to take more time to complete than the others, often due to faulty hardware, or underpowered machines. This execution time may cause a bottleneck since all mappers need to finish before any reducers can kick-off. Hadoop uses speculative execution to mitigate against such situations. If a Mapper appears to be running more sluggishly than the others, a new instance of the Mapper will be started on another machine, operating on the same data. The results of the first Mapper to finish will be used. Hadoop will kill off the Mapper which is still running.</p>

<h3 id="step-2-write-a-mapreduce-program-a-idwrite-a-mapreduce-programa">Step 2: Write a MapReduce Program <a id="write-a-mapreduce-program"></a></h3>

<p>In this section, you will learn how to use the Hadoop API to write a MapReduce program in Java.</p>

<p>Each of the portions (<strong>RecordReader, Mapper, Partitioner, Reducer, etc.</strong>) can be created by the developer. The developer is expected to at least write the Mapper, Reducer, and driver code.</p>

<h4 id="examine-the-mapreduce-example-a-idexamine-the-mapreduce-examplea">2.1 Examine The MapReduce Example <a id="examine-the-mapreduce-example"></a></h4>

<h5 id="mapreduce-wordcount-descrption">MapReduce WordCount Descrption</h5>

<p><strong>WordCount</strong> example reads text files and counts how often words occur. The input is text files and the output is text files. Each line contains a word and as the program counts how often words appear, it separates each word by a tab.</p>

<p>Each mapper takes a line as input and breaks it into words. It then emits a key/value pair of the word and 1. Each reducer sums the counts for each word and emits a single key/value with the word and sum.</p>

<p>As an optimization, the reducer is also used as a combiner on the map outputs. This reduces the amount of data sent across the network by combining each word into a single record.</p>

<p>To run the example, copy and paste the command</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>hadoop jar hadoop-<span class="k">*</span>-examples.jar wordcount <span class="o">[</span>-m &lt;<span class="c">#maps&gt;] [-r &lt;#reducers&gt;] &lt;in-dir&gt; &lt;out-dir&gt;</span>
</code></pre>
</div>

<p>All of the files in the input directory are read and the number of words in the input are written to the output directory. It is assumed that both inputs and outputs are stored in HDFS. If your input is not already in HDFS, but rather in a local file system somewhere, you need to copy the data into HDFS using a command like this:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>hadoop dfs -copyFromLocal &lt;<span class="nb">local</span>-dir&gt; &lt;hdfs-dir&gt;
</code></pre>
</div>

<h5 id="wordcount-java-code">WordCount Java Code</h5>

<p>Below is the standard wordcount example implemented in Java:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>        <span class="kn">package</span> <span class="n">org</span><span class="o">.</span><span class="na">myorg</span><span class="o">;</span>

        <span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
        <span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

        <span class="kn">import</span> <span class="nn">org.apache.hadoop.fs.Path</span><span class="o">;</span>
        <span class="kn">import</span> <span class="nn">org.apache.hadoop.conf.*</span><span class="o">;</span>
        <span class="kn">import</span> <span class="nn">org.apache.hadoop.io.*</span><span class="o">;</span>
        <span class="kn">import</span> <span class="nn">org.apache.hadoop.mapreduce.*</span><span class="o">;</span>
        <span class="kn">import</span> <span class="nn">org.apache.hadoop.mapreduce.lib.input.FileInputFormat</span><span class="o">;</span>
        <span class="kn">import</span> <span class="nn">org.apache.hadoop.mapreduce.lib.input.TextInputFormat</span><span class="o">;</span>
        <span class="kn">import</span> <span class="nn">org.apache.hadoop.mapreduce.lib.output.FileOutputFormat</span><span class="o">;</span>
        <span class="kn">import</span> <span class="nn">org.apache.hadoop.mapreduce.lib.output.TextOutputFormat</span><span class="o">;</span>

        <span class="kd">public</span> <span class="kd">class</span> <span class="nc">WordCount</span> <span class="o">{</span>

         <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Map</span> <span class="kd">extends</span> <span class="n">Mapper</span><span class="o">&lt;</span><span class="n">LongWritable</span><span class="o">,</span> <span class="n">Text</span><span class="o">,</span> <span class="n">Text</span><span class="o">,</span> <span class="n">IntWritable</span><span class="o">&gt;</span> <span class="o">{</span>
            <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="n">IntWritable</span> <span class="n">one</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IntWritable</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
            <span class="kd">private</span> <span class="n">Text</span> <span class="n">word</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Text</span><span class="o">();</span>

            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">map</span><span class="o">(</span><span class="n">LongWritable</span> <span class="n">key</span><span class="o">,</span> <span class="n">Text</span> <span class="n">value</span><span class="o">,</span> <span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">InterruptedException</span> <span class="o">{</span>
                <span class="n">String</span> <span class="n">line</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
                <span class="n">StringTokenizer</span> <span class="n">tokenizer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">tokenizer</span><span class="o">.</span><span class="na">hasMoreTokens</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">word</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">tokenizer</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="n">context</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">one</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
         <span class="o">}</span> 

         <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Reduce</span> <span class="kd">extends</span> <span class="n">Reducer</span><span class="o">&lt;</span><span class="n">Text</span><span class="o">,</span> <span class="n">IntWritable</span><span class="o">,</span> <span class="n">Text</span><span class="o">,</span> <span class="n">IntWritable</span><span class="o">&gt;</span> <span class="o">{</span>

            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">Text</span> <span class="n">key</span><span class="o">,</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">IntWritable</span><span class="o">&gt;</span> <span class="n">values</span><span class="o">,</span> <span class="n">Context</span> <span class="n">context</span><span class="o">)</span> 
              <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">InterruptedException</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="k">for</span> <span class="o">(</span><span class="n">IntWritable</span> <span class="n">val</span> <span class="o">:</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">sum</span> <span class="o">+=</span> <span class="n">val</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="n">context</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="k">new</span> <span class="n">IntWritable</span><span class="o">(</span><span class="n">sum</span><span class="o">));</span>
            <span class="o">}</span>
         <span class="o">}</span>

         <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
            <span class="n">Configuration</span> <span class="n">conf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Configuration</span><span class="o">();</span>

                <span class="n">Job</span> <span class="n">job</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Job</span><span class="o">(</span><span class="n">conf</span><span class="o">,</span> <span class="s">"wordcount"</span><span class="o">);</span>

            <span class="n">job</span><span class="o">.</span><span class="na">setOutputKeyClass</span><span class="o">(</span><span class="n">Text</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="n">job</span><span class="o">.</span><span class="na">setOutputValueClass</span><span class="o">(</span><span class="n">IntWritable</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

            <span class="n">job</span><span class="o">.</span><span class="na">setMapperClass</span><span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="n">job</span><span class="o">.</span><span class="na">setReducerClass</span><span class="o">(</span><span class="n">Reduce</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

            <span class="n">job</span><span class="o">.</span><span class="na">setInputFormatClass</span><span class="o">(</span><span class="n">TextInputFormat</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="n">job</span><span class="o">.</span><span class="na">setOutputFormatClass</span><span class="o">(</span><span class="n">TextOutputFormat</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

            <span class="n">FileInputFormat</span><span class="o">.</span><span class="na">addInputPath</span><span class="o">(</span><span class="n">job</span><span class="o">,</span> <span class="k">new</span> <span class="n">Path</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>
            <span class="n">FileOutputFormat</span><span class="o">.</span><span class="na">setOutputPath</span><span class="o">(</span><span class="n">job</span><span class="o">,</span> <span class="k">new</span> <span class="n">Path</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">1</span><span class="o">]));</span>

            <span class="n">job</span><span class="o">.</span><span class="na">waitForCompletion</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
         <span class="o">}</span>

        <span class="o">}</span>
</code></pre>
</div>

<p>Every MapReduce job consists of three portions</p>

<ul>
  <li>The driver code
    <ul>
      <li>Code that runs on the client to configure and submit the job</li>
    </ul>
  </li>
  <li>The Mapper</li>
  <li>The Reducer</li>
</ul>

<p>Before we look at the code, we need to cover some basic <strong>Hadoop API concepts.</strong></p>

<h4 id="mapper-reading-data-from-hdfs-a-idmapper-reading-data-hdfsa">2.2 Mapper reading data from HDFS <a id="mapper-reading-data-hdfs"></a></h4>

<p>The data passed to the Mapper is specified by an InputFormat. The InputFormat is specified in the driver code. It defines the location of the input data like a file or directory on HDFS. It also determines how to split the input data into input splits.</p>

<p>Each Mapper deals with a single input split. InputFormat is a factory for RecordReader objects to extract (key, value) records from the input source.</p>

<p>FilelnputFormat is the base class used for all file-based InputFormats. TextlnputFormat is the default FilelnputFormat. It treats each \n-terminated line of a file as a value. The Key is the byte offset within the file of that line. KeyValueTextlnputFormat maps \n-terminated lines as 'key SEP value'. By default, separator is a tab. SequenceFilelnputFormat is a binary file of (key, value) pairs with some additional metadata. SequenceFileAsTextlnputFormat is similar, but maps (key.toString( ), value.toString( )).</p>

<p>Keys and values in Hadoop are objects. Values are objects which implement the writable interface. Keys are objects which implement writableComparable.</p>

<h4 id="writable">Writable</h4>

<p>Hadoop defines its own 'box classes' for strings, integers and so on:</p>

<ul>
  <li>IntWritable for ints</li>
  <li>LongWritable for longs</li>
  <li>FloatWritable for floats</li>
  <li>DoubleWritable for doubles</li>
  <li>Text for strings</li>
  <li>Etc.</li>
</ul>

<p>The writable interface makes serialization quick and easy for Hadoop. Any value's type must implement the writable interface.</p>

<h4 id="writablecomparable">WritableComparable</h4>

<p>A WritableComparable is a Writable, which is also Comparable. Two writableComparables can be compared against each other to determine their 'order'. Keys must be WritableComparables because they are passed to the Reducer in sorted order.</p>

<p>Note that despite their names, all Hadoop box classes implement both Writable and WritableComparable, for example, intwritable is actually a WritableComparable</p>

<h4 id="driver">Driver</h4>

<p>The driver code runs on the client machine. It configures the job, then submits it to the cluster.</p>

<h4 id="streaming-api-a-idstreaming-apia">2.3 Streaming API <a id="streaming-api"></a></h4>

<p>Many organizations have developers skilled in languages other than Java, such as</p>

<ul>
  <li>C#</li>
  <li>Ruby</li>
  <li>Python</li>
  <li>Perl</li>
</ul>

<p>The Streaming API allows developers to use any language they wish to write Mappers and Reducers as long as the language can read from standard input and write to standard output.</p>

<p>The advantages of the Streaming API are that there is no need for non-Java coders to learn Java. So it results in faster development time and the ability to use existing code libraries.</p>

<h4 id="how-streaming-works">How Streaming Works</h4>

<p>To implement streaming, write separate Mapper and Reducer programs in the language of your choice. They will receive input via stdin. They should write their output to stdout.</p>

<p>If TextinputFormat (the default) is used, the streaming Mapper just receives each line from the file on stdin where no key is passed. Streaming Mapper and streaming Reducer's output should be sent to stdout as key (tab) value (newline) and the Separators other than tab can be specified.</p>

<p>In Java, all the values associated with a key are passed to the Reducer as an iterator. Using Hadoop Streaming, the Reducer receives its input as (key, value) pairs, one per line of standard input.</p>

<p>Your code will have to keep track of the key so that it can detect when values from a new key start appearing launching a Streaming Job .To launch a Streaming job, use e.g.,:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>hadoop jar <span class="nv">$HADOOP_HOME</span>/contrib/streaming/hadoop-streaming<span class="k">*</span>.jar <span class="se">\</span>
-input mylnputDirs <span class="se">\ </span>-output myOutputDir <span class="se">\</span>
-mapper myMap.py <span class="se">\</span>
-reducer myReduce.py <span class="se">\ </span>-file myMap.py <span class="se">\ </span>-file myReduce.py
</code></pre>
</div>

<h4 id="repositories-a-idrepositories-hortonworksa">2.4 Repositories <a id="repositories-hortonworks"></a></h4>

<p>At Hortonworks, we store all of our artifacts in a public Sonatype Nexus repository. That repository can be easily accessed and searched for commonly used library, source code, and javadoc archives simply by navigating to <a href="http://repo.hortonworks.com">http://repo.hortonworks.com</a>.</p>

<h4 id="artifacts">Artifacts</h4>

<p>Jar files containing compiled classes, source, and javadocs are all available in our public repository, and finding the right artifact with right version is as easy as searching the repository for classes you need to resolve.</p>

<p>For example, If creating a solution that requires the use of a class such as org.apache.hadoop.fs.FileSystem, you can simply search our public repository for the artifact that contains that class using the search capabilities available through <a href="http://repo.hortonworks.com">http://repo.hortonworks.com</a>. Searching for that class will locate the hadoop-common artifact that is part of the org.apache.hadoop group. There will be multiple artifacts each with a different version.</p>

<p>Artifacts in our repository use a 7 digit version scheme. So if we're looking at the 2.7.1.2.4.0.0-169 version of this artifact:</p>

<ul>
  <li>The first three digits (2.7.1) signify the Apache Hadoop base version</li>
  <li>The next four digits (2.4.0.0) signify our Hortonworks Data Platform release</li>
  <li>The final numbers after the hyphen (169) signifies the build number</li>
</ul>

<p>As you're looking for the right artifact, it's important to use the artifact version that corresponds to the HDP version you plan to deploy to. You can determine this by using <code class="highlighter-rouge">hdp-select versions</code> from the command line, or using Ambari by navigating to <code class="highlighter-rouge">Admin &gt; Stack and Versions</code>. If neither of these are available in your version of HDP or Ambari, you can use yum, zypper, or dpkg to query the RPM or Debian packages installed for HDP and note their versions.</p>

<p>Once the right artifact has been found with the version that corresponds to your target HDP environment, it's time to configure your build tool to both resolve our repository and include the artifact as a dependency. The following section outlines how to do both with commonly used with build tools such as Maven, SBT, and Gradle.</p>

<h4 id="maven-setup">Maven Setup</h4>

<p>Apache Maven, is an incredibly flexible build tool used by many Hadoop ecosystem projects. In this section, we will outline what updates to your project's pom.xml file are required to start resolving HDP artifacts.</p>

<h4 id="repository-configuration">Repository Configuration</h4>

<p>The pom.xml file enables flexible definition of project dependencies and build procedures. To add the Hortonworks repository to your project, allowing HDP artifacts to be resolved, edit the section and add a entry as illustrated below:</p>

<div class="language-html highlighter-rouge"><pre class="highlight"><code>      <span class="nt">&lt;repositories&gt;</span>

       <span class="nt">&lt;repository&gt;</span>

         <span class="nt">&lt;id&gt;</span>HDP<span class="nt">&lt;/id&gt;</span>

         <span class="nt">&lt;name&gt;</span>HDP Releases<span class="nt">&lt;/name&gt;</span>

         <span class="nt">&lt;url&gt;</span>http://repo.hortonworks.com/content/repositories/releases/<span class="nt">&lt;/url&gt;</span>

       <span class="nt">&lt;/repository&gt;</span>    

      <span class="nt">&lt;/repositories&gt;</span>
</code></pre>
</div>

<h4 id="artifact-configuration">Artifact Configuration</h4>

<p>Dependencies are added to Maven using the tag within the section of the pom.xml. To add a dependency such as hadoop-common, add this fragment:</p>

<div class="language-html highlighter-rouge"><pre class="highlight"><code>    <span class="nt">&lt;dependency&gt;</span>
       <span class="nt">&lt;groupId&gt;</span>org.apache.hadoop<span class="nt">&lt;/groupId&gt;</span>
       <span class="nt">&lt;artifactId&gt;</span>hadoop-common<span class="nt">&lt;/artifactId&gt;</span>
       <span class="nt">&lt;version&gt;</span>2.7.1.2.4.0.0-169<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;/dependency&gt;</span>
</code></pre>
</div>

<p>Once both the repository has been added to the repositories section, and the artifacts have been added to the dependencies section, a simple <code class="highlighter-rouge">mvn compile</code> can be issued from the base directory of your project to ensure that proper syntax has been used and the appropriate dependencies are downloaded.</p>

<h4 id="source--javadoc-a-idsource-javadoca">2.5 Source &amp; Javadoc <a id="source-javadoc"></a></h4>

<p>When using Maven with an IDE, it is often helpful to have the accompanying JavaDoc and source code. To obtain both from our repository for the artifacts that you have defined in your pom.xml, run the following commands from the base directory of your project:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>mvn dependency:sources

mvn dependency:resolve -Dclassifier<span class="o">=</span>javadoc
</code></pre>
</div>

<h4 id="sbt-setup-a-idsbt-setupa">2.6 SBT Setup <a id="sbt-setup"></a></h4>

<p>The Scala Build Tool is commonly used with Scala based projects, and provide simple configuration, and many flexible options for dependency and build management.</p>

<p>Repository Configuration</p>

<p>In order for SBT projects to resolve Hortonworks Data Platform dependencies, an additional resolvers entry must be added to your build.sbt file, or equivalent, as illustrated below:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>resolvers +<span class="o">=</span> <span class="s2">"Hortonworks Releases"</span> at <span class="s2">"[http://repo.hortonworks.com/content/repositories/releases/](http://repo.hortonworks.com/content/repositories/releases/)"</span>
</code></pre>
</div>

<h4 id="artifact-configuration-1">Artifact Configuration</h4>

<p>Dependencies can be added to SBT's libraryDependencies as illustrated below:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>libraryDependencies += "org.apache.hadoop" % "hadoop-common" % "2.7.1.2.4.0.0-169"
</code></pre>
</div>

<p>To explicitly ask SBT to also download source code and JavaDocs an alternate notation can be used:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>libraryDependencies += "org.apache.hadoop" % "hadoop-common" % "2.7.1.2.4.0.0-169" withSources() withJavadoc()
</code></pre>
</div>

<p>Once both the repository has been added to resolvers, and the artifacts have been added to dependencies, a simple sbt compile can be issued from the base directory of your project to ensure that proper syntax has been used and the appropriate dependencies are downloaded.</p>

<h4 id="gradle-setup-a-idgradle-setupa">2.7 Gradle Setup <a id="gradle-setup"></a></h4>

<p>The Gradle build management tool is used frequently in Open Source java projects, and provides a simple Groovy-based DSL for project dependency and build definition.</p>

<p>Plugin Configuration</p>

<p>Gradle uses plugins add functionality to add new task, domain objects and conventions to your gradle build. Add the following plugins to your build.gradle file, or equivalent, as illustrated below:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    apply plugin: 'java'

    apply plugin: 'maven'

    apply plugin: 'idea'  // Pick IDE appropriate for you

    apply plugin: 'eclipse' // Pick IDE appropriate for you
</code></pre>
</div>

<p>Repository Configuration</p>

<p>In order for Gradle projects to resolve Hortonworks Data Platform dependencies, an additional entry must be added to your build.gradle file, or equivalent, as illustrated below:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    repositories {



      maven { url "http://repo.hortonworks.com/content/repositories/releases/" }



    }
</code></pre>
</div>

<h4 id="artifact-configuration-2">Artifact Configuration</h4>

<p>Dependencies can be added to Gradle's dependencies section as illustrated below:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>      dependencies {

         compile group: "org.apache.hadoop", name: "hadoop-common", version: "2.7.1.2.3.2.0-2650"

      }

      idea {  // Pick IDE appropriate for you

        module {

            downloadJavadoc = true

            downloadSources = true

        }

      }



      eclipse {  // Pick IDE appropriate for you



        classpath {

            downloadSources = true

            downloadJavadoc = true

        }

      }

</code></pre>
</div>
<p>Once both the repositories and the dependencies have been added to build file, a simple gradle clean build can be issued from the base directory of your project to ensure that proper syntax has been used and the appropriate dependencies are downloaded.</p>

<h3 id="step-3-hive-and-pig-motivation-a-idhive-and-pig-motivationa">Step 3: Hive and Pig: Motivation <a id="hive-and-pig-motivation"></a></h3>

<p>MapReduce code is typically written in Java. Although it can be written in other languages using Hadoop</p>

<p>Streaming Requires a programmer who understands how to think in terms of MapReduce, who understands the problem they're trying to solve and who has enough time to write and test the code.</p>

<p>Many organizations have only a few developers who can write good MapReduce code</p>

<p>Meanwhile, many other people want to analyze data</p>

<ul>
  <li>Data analysts</li>
  <li>Business analysts</li>
  <li>Data scientists</li>
  <li>Statisticians</li>
</ul>

<p>So we needed a higher-level abstraction on top of MapReduce providing the ability to query the data without needing to know MapReduce intimately. Hive and Pig address these needs.</p>

<h2 id="further-reading-a-idfurther-reading-java-deva">Further Reading <a id="further-reading-java-dev"></a></h2>

<p>See the following tutorial for more on Hive and Pig:</p>

<ul>
  <li>Explore <a href="https://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html#MapReduce_Tutorial">MapReduce Tutorial</a></li>
  <li><a href="http://hortonworks.com/hadoop-tutorial/how-to-process-data-with-apache-hive/">Process Data with Apache Hive</a></li>
  <li><a href="http://hortonworks.com/hadoop-tutorial/how-to-process-data-with-apache-pig/">Process Data with Apache Pig</a></li>
  <li><a href="http://hortonworks.com/hadoop-tutorial/cascading-log-parsing/">Get Started with Cascading on Hortonworks Data Platform</a></li>
  <li><a href="http://hortonworks.com/hadoop-tutorial/supercharging-interactive-queries-hive-tez/">Interactive Query for Hadoop with Apache Hive on Apache Tez</a></li>
  <li>
    <p><a href="http://hortonworks.com/hadoop-tutorial/exploring-data-apache-pig-grunt-shell/">Exploring Data with Apache Pig from the Grunt shell</a></p>
  </li>
  <li>We have many <a href="http://hortonworks.com/tutorials">tutorials</a> which you can use with the Hortonworks Sandbox to learn about a rich and diverse set of components of the Hadoop platform.</li>
</ul>

</div>

<div id="tutorial-footer">
  <hr>
  <h2>Tutorial Q&amp;A and Reporting Issues</h2>
  <p>If you need help or have questions with this tutorial, please first check HCC for existing Answers to questions on this tutorial using the Find Answers button.  If you don't find your answer you can post a new HCC question for this tutorial using the Ask Questions button.</p>
  <p><a class="btn" href="https://community.hortonworks.com/topics/tutorial-130.html" role="button">Find Answers</a> <a class="btn pull-right" href="https://community.hortonworks.com/questions/ask.html?space=81&topics=tutorial-130&topics=hdp-2.4.0" role="button">Ask Questions</a></p>
  <p>Tutorial Name: <strong>Introducing Apache Hadoop to Developers</strong></p>
  <p>HCC Tutorial Tag:<strong> tutorial-130</strong> and <strong>hdp-2.4.0</strong></p>
  <p>If the tutorial has multiple labs please indicate which lab your question corresponds to. Please provide any feedback related to that lab.</p>
  <p>All Hortonworks, partner and community tutorials are posted in the Hortonworks github and can be contributed via the <a href="https://github.com/hortonworks/tutorials/wiki">Hortonworks Tutorial Contribution Guide</a>.  If you are certain there is an issue or bug with the tutorial, please <a href="https://github.com/hortonworks/tutorials/wiki#issues-with-tutorials">create an issue</a> on the repository and we will do our best to resolve it!</p>
</div>
